package p20250429

import "fmt"

/*
2962-统计最大元素出现至少 K 次的子数组

给你一个整数数组 nums 和一个 正整数 k 。
请你统计有多少满足 「 nums 中的 最大 元素」至少出现 k 次的子数组，并返回满足这一条件的子数组的数目。
子数组是数组中的一个连续元素序列。

示例 1：
输入：nums = [1,3,2,3,3], k = 2
输出：6
解释：包含元素 3 至少 2 次的子数组为：[1,3,2,3]、[1,3,2,3,3]、[3,2,3]、[3,2,3,3]、[2,3,3] 和 [3,3] 。

示例 2：
输入：nums = [1,4,2,1], k = 3
输出：0
解释：没有子数组包含元素 4 至少 3 次。

提示：
1 <= nums.length <= 105
1 <= nums[i] <= 106
1 <= k <= 105
*/

func CountSubarraysTest() {
	// fmt.Println(countSubarrays([]int{1, 3, 2, 3, 3}, 2))
	fmt.Println(countSubarrays([]int{1, 3, 2, 3, 3, 1, 1, 2}, 2))
}

func countSubarrays(nums []int, k int) int64 {
	// 这里是理解了官方题解中的思想，就是利用滑动窗口的原理
	// 首先找到数组中的最大值
	// 然后开始遍历找刚好符合的区间，然后进行计算有多少合适的
	/*
		|→1, 3, 2, 3←|, 3, 1, 1, 2  这是刚满足的时候，此时左移左指针，直到不满足的时候
		1, 3, |→2, 3←|, 3, 1, 1, 2  此时左指针左边的区间的右边连续内容+当前区间的内容就是满足的
		此时满足的数量为 323 1323  一共 2 种
		此时继续将右指针往右移动一次，然后可以再次计算满足数量
		1, 3, |→2, 3, 3←|, 1, 1, 2  这是满足的时候，此时左移左指针，直到不满足的时候
		// 如果本来就是不满足的情况，就不用移动左指针，可以直接按照当前的计算左指针区间的数量计算次数
		1, 3, 2, 3, |→3←|, 1, 1, 2  此时左指针左边的区间的右边连续内容+当前区间的内容就是满足的
		这里其实也包含了超过满足数量的情况，这里也一并包含在里面
		这里就不会出现重复的情况，因为当前区间每次都是最新的，每次只是左指针左边区间的内容数量变化
		此时满足的数量为 33 233 3233 13233  一共 4 种

		继续移动右指针
		1, 3, 2, 3, |→3, 1←|, 1, 2
		满足的有 331 2331 32331 132331  一共 4 种

		继续移动右指针
		1, 3, 2, 3, |→3, 1, 1←|, 2
		满足的有 3311 23311 323311 1323311  一共 4 种

		继续移动右指针
		1, 3, 2, 3, |→3, 1, 1, 2←|
		满足的有 33112 233112 3233112 13233112  一共 4 种

		此时右指针已经到达数组末尾，结束遍历

		总共满足的数量为 2 + 4 + 4 + 4 + 4 = 18 种
	*/

	// 找出数组中的最大值
	mMaxNum := nums[0]
	for _, num := range nums {
		if num > mMaxNum {
			mMaxNum = num
		}
	}

	// 根据找到的最大值开始遍历数组，找到满足条件的区间
	mMaxCnt := 0        // 当前区间内最大数组的数量
	mLeftIdx := 0       // 左指针
	mRetNum := int64(0) // 返回结果
	for _, num := range nums {
		// 如果这个数是最大的值，那就将计数+1
		if num == mMaxNum {
			mMaxCnt++
		}

		// 当前区间是 [mLeftIdx, i]，这里的 i 省略了，是右指针，对应 num 的下标
		// 判断当前区间内满足条件的数是否满足 k 个
		// 如果满足，就开始将左指针向右移动，直到不满足为止，然后就可以开始计数了
		for mMaxCnt == k {
			if nums[mLeftIdx] == mMaxNum {
				// 如果当前做下标对应的这个数 等于 当前数组中最大的值，此时计数需要-1
				// 因为在这个for循环中，左指针会一直向右移，直到不满足条件为止
				mMaxCnt--
			}

			// 这里就是这个for中需要一直将左指针向右移动，直到不满足条件为止
			mLeftIdx++
		}

		// 如果右指针向右移动后当前的区间不满足，没有走上面的，也是需要进行计算左指针左边的数量
		// 因为当前区间一直都是最新的，然后加上左边连续的都是满足条件的，所以这里是需要加的
		// 这里对于开始区间内不满足的时候，这里的mLeftIdx一直是0，所以这里一直+0也没关系
		mRetNum += int64(mLeftIdx)
	}

	return mRetNum
}

// 这种想法是不对的，直接舍弃，因为会有很多重复的区间，没有办法获取争取的数量
func countSubarrays1(nums []int, k int) int64 {

	// 首先需要找到数组中的最大值
	// 然后就是遍历数组中能够满足最大值出现不少于 k 次的连续数组

	// 2个下标指针可以确定一个区间，看这个区间中是否有 k 个最大值
	// 开始假设区间大小是0，然后开始扩大区间
	// 当区间内的最大值满足要求后开始计算当前这种区间的情况下，可以有多少种区间满足要求

	/*
		|→1, 3, 2, 3←|, 3, 1, 1, 2  这是 1 种
		左指针右移 1 位
		1, |→3, 2, 3←|, 3, 1, 1, 2  依旧满足，这是 1 种
		加上以当前区间为后缀，再加上左指针前面的区间有 1 位，所以这里还有 1 种
		左指针右移 1 位
		1, 3, |→2, 3←|, 3, 1, 1, 2  此时不满足
		右指针右移 1 位
		1, 3, |→2, 3, 3←|, 1, 1, 2  此时满足，这是 1 种
		加上以当前区间为后缀，再加上左指针前面的区间有 2 位，所以这里还有 2 种
		左指针右移 1 位
		1, 3, 2, |→3, 3←|, 1, 1, 2  此时满足，这是 1 种
		加上以当前区间为后缀，再加上左指针前面的区间有 3 位，所以这里还有 3 种
		左指针右移 1 位
		1, 3, 2, 3, |→3←|, 1, 1, 2  此时不满足
		右指针右移 1 位
		1, 3, 2, 3, |→3, 1←|, 1, 2  此时不满足
		右指针右移 1 位
		1, 3, 2, 3, |→3, 1, 1←|, 2  此时不满足
		右指针右移 1 位
		1, 3, 2, 3, |→3, 1, 1, 2←|  此时不满足

		本次遍历完毕  左指针一共右移了 4 次  有指针满足后又移动了 4 次

		开始反向遍历，从数组末尾开始遍历，跟上面相反的情况
		1, 3, 2, |→3, 3, 1, 1, 2←|  这是 1 种
		右指针左移 1 位
		1, 3, 2, |→3, 3, 1, 1←|, 2  这是 1 种
		加上以当前区间为前缀，再加上右指针后面的区间有 1 位，所以这里还有 1 种
		右指针左移 1 位
		1, 3, 2, |→3, 3, 1←|, 1, 2  这是 1 种
		加上以当前区间为前缀，再加上右指针后面的区间有 2 位，所以这里还有 2 种
		右指针左移 1 位
		1, 3, 2, |→3, 3←|, 1, 1, 2  这是 1 种
		加上以当前区间为前缀，再加上右指针后面的区间有 3 位，所以这里还有 3 种
		右指针左移 1 位
		1, 3, 2, |→3←|, 3, 1, 1, 2  此时不满足
		左指针左移 1 位
		1, 3, |→2, 3←|, 3, 1, 1, 2  此时不满足
		左指针左移 1 位
		1, |→3, 2, 3←|, 3, 1, 1, 2  这是 1 种
		加上以当前区间为前缀，再加上右指针后面的区间有 4 位，所以这里还有 4 种
		右指针左移 1 位
		1, |→3, 2←|, 3, 3, 1, 1, 2  此时不满足
		左指针左移 1 位
		|→1, 3, 2←|, 3, 3, 1, 1, 2  此时不满足

		本次遍历完毕  右指针一共左移了 5 次  左指针满足够由移动了 3 次

		两次遍历一共记录下的情况 = 第一次遍历（共10种） + 第二次遍历（共15种）
	*/

	return 0
}
