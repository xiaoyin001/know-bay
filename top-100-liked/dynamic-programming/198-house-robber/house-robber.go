package houserobber

import "fmt"

/*
198-打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

提示：
1 <= nums.length <= 100
0 <= nums[i] <= 400
*/

func RobTest() {
	// fmt.Println(rob([]int{1, 2, 3, 1}))
	fmt.Println(rob([]int{1, 0, 0, 0, 1}))
}

func rob(nums []int) int {
	// 刚开始回想着如果很大的数字在一起，是不是可以有办法给都弄到
	// 就比如大的数字中间是两个0间隔着，是不是可以中间2个0都跳过
	// 然后还在想中间跳跃更多呢，这里其实就是想多了
	// 如果跳跃更多，前面就是一家隔一家的，到了大的数字，在进行比较，这样就不用考虑太多户
	// 总的来说就是看当前户、前户、前前户，这三户并不是代码真的当前户
	// 而是代表偷到这一户可以偷的最大金额，然后将这个最大的数字进行记录，用于继续向后遍历得到结果

	// 如果可以偷的用户是0，直接表示没有可偷的返回0
	if len(nums) == 0 {
		return 0
	}

	// 如果只有一户可偷，直接返回这一家的金额就是最大的
	if len(nums) == 1 {
		return nums[0]
	}
	mMax1 := nums[0] // 偷到下标为0的户，可以偷到的最大金额

	// 如果是有2户可偷，又不能连续偷，所以就看当前户和前一户那个金额更高，就偷哪个
	mMax2 := max(mMax1, nums[1])

	// 如果不止2户可偷，那么就继续向后遍历，继续计算偷到当前户的最大金额
	for i := 2; i < len(nums); i++ {
		// 这里是需要从第3户开始偷，所以是i=2开始

		// 当前已经在考虑是否要偷第三家了
		// 如果偷第3户，那就可以偷第1户，不能偷第2户
		// 如果不偷第3户，那么就偷第2户，不能偷第1户
		// 所以这里是否要偷第3户就是一个问题，这里就比较 (偷当前户+前前户最高和) 与 (前户最高和) 的大小
		// 那个金额高，就是当前户可以偷到的最大金额
		mMax1, mMax2 = mMax2, max(mMax1+nums[i], mMax2)
	}

	// 这里为什么是返回 mMax2 呢
	// 因为 mMax2 是偷到指定户可得的最大金额
	// 就比如如果偷2户，mMax2 就是这2户取较大的金额
	// 如果是3户，最后 mMax2 就是比较 偷1、3户和偷2户哪个金额高
	// 第2户也好，第n户也好，for里面每一遍执行都会更新 mMax2 ，让其始终保持为有当前户的情况下可偷金额最大化的值

	return mMax2
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
